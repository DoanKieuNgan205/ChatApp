#include "ChatServer.h"
#include "RegisterController.h" 
#include "LoginController.h"
#include "DatabaseHelper.h"
#include "FileServer.h"
#include "VoiceServer.h"
#include <iostream>
#include <algorithm>
#include <mutex>
#include <map>
#include <vector>
#include <string>
#include <algorithm> // Cho std::remove
#include <thread>    // Cho std::thread


using namespace std;

extern DatabaseHelper db; // d√πng l·∫°i bi·∫øn db t·ª´ main

vector<SOCKET> clients;
//map<string, SOCKET> userMap; 
mutex mtx;
FileServer fileServer;     // ‚úÖ t·∫°o 1 ƒë·ªëi t∆∞·ª£ng FileServer to√†n c·ª•c
VoiceServer voiceServer;   // ‚úÖ Server ph·ª• tr√°ch truy·ªÅn √¢m thanh UDP

// üîπ H√†m t√°ch field t·ª´ JSON ƒë∆°n gi·∫£n
string parseField(const string& json, const string& field) {
    size_t pos = json.find("\"" + field + "\"");
    if (pos == string::npos) return "";
    pos = json.find(":", pos);
    if (pos == string::npos) return "";
    pos = json.find("\"", pos);
    if (pos == string::npos) return "";
    size_t end = json.find("\"", pos + 1);
    if (end == string::npos) return "";
    return json.substr(pos + 1, end - pos - 1);
}

// üîπ G·ª≠i tin nh·∫Øn ƒë·∫øn t·∫•t c·∫£ client tr·ª´ ng∆∞·ªùi g·ª≠i
void broadcast(const string& msg, SOCKET sender) {
    lock_guard<mutex> lock(mtx);
    for (SOCKET c : clients) {
        if (c != sender) {
            int ret = send(c, msg.c_str(), (int)msg.size(), 0);
            if (ret == SOCKET_ERROR) {
                cerr << "Send error: " << WSAGetLastError() << endl;
            }
        }
    }
}

// üîπ G·ª≠i tin nh·∫Øn ri√™ng
void sendToUser(const string& username, const string& msg) {
    lock_guard<mutex> lock(mtx);
    auto it = userMap.find(username);
    if (it != userMap.end()) {
        send(it->second, msg.c_str(), (int)msg.size(), 0);
    }
}

// üîπ G·ª≠i danh s√°ch user online cho t·∫•t c·∫£ client
void sendOnlineList() {
    lock_guard<mutex> lock(mtx);
    string list = "{ \"action\": \"online_list\", \"users\": [";
    bool first = true;
    for (const auto& pair : userMap) {
        if (!first) list += ",";
        list += "\"" + pair.first + "\"";
        first = false;
    }
    list += "] }\n";

    for (SOCKET c : clients) {
        send(c, list.c_str(), (int)list.size(), 0);
    }
}

// üîπ X·ª≠ l√Ω t·ª´ng client
void handleClient(SOCKET client) {
    string request;
    char buf[4096];
    int bytes = 0;

    // Nh·∫≠n g√≥i login (c√≥ th·ªÉ ƒë·∫øn nhi·ªÅu ƒë·ª£t)
    while (true) {
        bytes = recv(client, buf, sizeof(buf)-1, 0);
        if (bytes <= 0) {
            closesocket(client);
            return;
        }
        buf[bytes] = '\0';
        request += buf;

        // Khi nh·∫≠n ƒë·ªß JSON c√≥ "}" th√¨ tho√°t v√≤ng l·∫∑p
        if (request.find('}') != string::npos) break;
    }

    string action = parseField(request, "action");

    // ‚úÖ N·∫øu client g·ª≠i y√™u c·∫ßu ƒëƒÉng k√Ω t√†i kho·∫£n
    if (action == "register") {
        string result = RegisterController::handleRegister(request);
        send(client, result.c_str(), (int)result.size(), 0);
        closesocket(client);
        return; // kh√¥ng c·∫ßn gi·ªØ k·∫øt n·ªëi sau khi ƒëƒÉng k√Ω
    }

    // ‚úÖ N·∫øu client g·ª≠i y√™u c·∫ßu ƒëƒÉng nh·∫≠p
    else if (action == "login") {
        // Ki·ªÉm tra login b·∫±ng DB (qua LoginController + Auth + DatabaseHelper)
        string loginResult = LoginController::handleLogin(request);
        string username = parseField(request, "username");
        if (username.empty()) {
            cout << "[WARN] Username tr·ªëng ‚Äî ƒë√≥ng k·∫øt n·ªëi\n";
            closesocket(client);
            return;
        }

        // th√™m \n cho JSON login
        loginResult += "\n";
        send(client, loginResult.c_str(), (int)loginResult.size(), 0);


        string status = parseField(loginResult, "status");
        cout << "[DEBUG] loginResult: " << loginResult << endl;
        cout << "[DEBUG] status parse: " << status << endl;
        if (status != "success") {
            cout << "[DEBUG] Login failed for user: " << username << endl;
            closesocket(client);
            return;
        }
        cout << "[DEBUG] Login success for user: " << username << endl;

        {
            lock_guard<mutex> lock(mtx);
            clients.push_back(client);
            userMap[username] = client;
        }
        sendOnlineList(); // ‚úÖ g·ª≠i danh s√°ch online sau khi user v√†o

        cout << "[INFO] User login: " << username << endl;

        // G·ª≠i l·ªãch s·ª≠ chat cho user sau khi ƒëƒÉng nh·∫≠p
        vector<string> history = db.getChatHistory(username);
        if (!history.empty()) {
            cout << "[INFO] Gui lich su chat cho user: " << username << " (" << history.size() << " tin nhan)\n";
            for (auto& line : history) {
                string safeMsg = line;
                // Escape k√Ω t·ª± " ƒë·ªÉ kh√¥ng l·ªói JSON
                for (size_t pos = 0; (pos = safeMsg.find("\"", pos)) != string::npos; pos += 2)
                    safeMsg.replace(pos, 1, "\\\"");

                string formatted = "{ \"action\": \"history\", \"message\": \"" + safeMsg + "\" }\n";
                send(client, formatted.c_str(), (int)formatted.size(), 0);
            }
        }

        
        // V√≤ng l·∫∑p chat
        while (true) {
            int bytes = recv(client, buf, sizeof(buf)-1, 0);
            if (bytes <= 0) break;
            buf[bytes] = '\0';
            string msg(buf);

            string action = parseField(msg, "action");


            if (action == "list") {
                string list = "{ \"action\": \"online_list\", \"users\": [";
                {
                    lock_guard<mutex> lock(mtx);
                    bool first = true;
                    for (const auto& pair : userMap) {
                        if (!first) list += ",";
                        list += "\"" + pair.first + "\"";
                        first = false;
                    }
                }
                list += "] }\n";
                send(client, list.c_str(), (int)list.size(), 0);
            }
            
            else if (action == "private") {
                string from = parseField(msg, "from");
                string to = parseField(msg, "to");
                string message = parseField(msg, "message");
                if (!from.empty() && !to.empty() && !message.empty()) {
                    // T·∫°o g√≥i JSON chu·∫©n
                    string chatMsg = "{ \"action\": \"private\", \"from\": \"" + from +
                                    "\", \"to\": \"" + to +
                                    "\", \"message\": \"" + message + "\" }\n";
                    sendToUser(to, chatMsg);
                    sendToUser(from, chatMsg);
                    db.saveMessage(from, to, message); // L∆∞u tin nh·∫Øn v√†o DB
                }
            }
            

            else if (action == "sendfile") {
                string from = parseField(msg, "from");
                string to = parseField(msg, "to");
                string filename = parseField(msg, "filename");
                string sizeStr = parseField(msg, "size");

                cout << "[INFO] " << from << " muon gui file " << filename << " (" << sizeStr << " bytes) -> " << to << endl;

                // Tr·∫£ l·ªùi client bi·∫øt r·∫±ng h√£y m·ªü k·∫øt n·ªëi ri√™ng ƒë·∫øn port 9999
                string notify = "{ \"action\": \"file_ready\", \"port\": 9999, \"message\": \"Hay gui file qua cong 9999\" }\n";
                send(client, notify.c_str(), notify.size(), 0);
            }
            
            else if (action == "voice_register") {
                string username = parseField(msg, "username");
                string ip = parseField(msg, "ip");
                string portStr = parseField(msg, "port");

                if (username.empty() || ip.empty() || portStr.empty()) {
                    string err = R"({ "action": "error", "message": "Thong tin voice_register khong hop le" })";
                    send(client, err.c_str(), (int)err.size(), 0);
                    continue;
                }

                sockaddr_in addr;
                addr.sin_family = AF_INET;
                inet_pton(AF_INET, ip.c_str(), &addr.sin_addr);
                addr.sin_port = htons(stoi(portStr));

                voiceServer.registerClient(username, addr);
                string ok = R"({ "action": "voice_register_ok", "message": "Da dang ky voice thanh cong" })" "\n";
                send(client, ok.c_str(), (int)ok.size(), 0);

                cout << "[VOICE] " << username << " ƒëƒÉng k√Ω ƒë·ªãa ch·ªâ UDP " << ip << ":" << portStr << endl;
            }

            else if (action == "voice_call") {
                string from = parseField(msg, "from");
                string to = parseField(msg, "to");

                if (from.empty() || to.empty()) {
                    string err = R"({ "action": "error", "message": "Th√¥ng tin cu·ªôc g·ªçi kh√¥ng h·ª£p l·ªá" })";
                    send(client, err.c_str(), (int)err.size(), 0);
                    continue;
                }

                // G·ª≠i y√™u c·∫ßu t·ªõi ng∆∞·ªùi nh·∫≠n
                string callMsg = "{ \"action\": \"incoming_call\", \"from\": \"" + from + "\" }\n";
                sendToUser(to, callMsg);
                cout << "[VOICE] Cu·ªôc g·ªçi voice t·ª´ " << from << " ƒë·∫øn " << to << endl;
            }
            

            else { // Chat chung
                string message = parseField(msg, "message");
                if (!username.empty() && !message.empty()) {
                    string chatMsg = username + ": " + message;
                    cout << chatMsg << endl;
                    broadcast(chatMsg, client);
                    db.saveMessage(username, "ALL", message); // L∆∞u chat chung
                }
            }
        }

        {
            lock_guard<mutex> lock(mtx);
            clients.erase(remove(clients.begin(), clients.end(), client), clients.end());
            userMap.erase(username);
        }
        closesocket(client);
        sendOnlineList(); // ‚úÖ g·ª≠i l·∫°i danh s√°ch khi user tho√°t

        cout << "[INFO] User disconnected: " << username << endl;
    }

    else {
        string err = R"({ "action": "error", "message": "Unknown action" })" "\n";
        send(client, err.c_str(), (int)err.size(), 0);
        closesocket(client);
    }
}

/*#include "ChatServer.h"
#include "DatabaseHelper.h"
#include "Packet.h"
#include <iostream>
#include <mutex>
#include <map>
#include <vector>
#include <algorithm>

using namespace std;

// D√πng bi·∫øn to√†n c·ª•c ƒë√£ khai b√°o ·ªü main
extern DatabaseHelper db;
extern std::map<std::string, SOCKET> userMap;
extern std::mutex mtx;
extern std::vector<SOCKET> clients;

// üîπ H√†m ph·ª•: parse field t·ª´ JSON (ƒë∆°n gi·∫£n)
static std::string parseField(const std::string& json, const std::string& field) {
    size_t pos = json.find("\"" + field + "\"");
    if (pos == string::npos) return "";
    pos = json.find(":", pos);
    if (pos == string::npos) return "";
    pos = json.find("\"", pos);
    if (pos == string::npos) return "";
    size_t end = json.find("\"", pos + 1);
    if (end == string::npos) return "";
    return json.substr(pos + 1, end - pos - 1);
}

// üîπ G·ª≠i tin nh·∫Øn t·ªõi to√†n b·ªô client tr·ª´ ng∆∞·ªùi g·ª≠i
void ChatServer::broadcast(const std::string& msg, SOCKET sender) {
    lock_guard<mutex> lock(mtx);
    for (SOCKET c : clients) {
        if (c != sender) {
            send(c, msg.c_str(), (int)msg.size(), 0);
        }
    }
}

// üîπ G·ª≠i ri√™ng tin nh·∫Øn ƒë·∫øn user
void ChatServer::sendToUser(const std::string& username, const std::string& msg) {
    lock_guard<mutex> lock(mtx);
    auto it = userMap.find(username);
    if (it != userMap.end()) {
        send(it->second, msg.c_str(), (int)msg.size(), 0);
    }
}

// üîπ X·ª≠ l√Ω g√≥i chat JSON t·ª´ client
std::string ChatServer::handleChat(const std::string& jsonRequest) {
    std::string action = parseField(jsonRequest, "action");
    std::string from = parseField(jsonRequest, "from");
    std::string to = parseField(jsonRequest, "to");
    std::string message = parseField(jsonRequest, "message");
    std::string username = parseField(jsonRequest, "username");

    // ‚úÖ Ng∆∞·ªùi d√πng v·ª´a JOIN chat
    if (action == "join_chat") {
        std::lock_guard<std::mutex> lock(mtx);
        if (!username.empty()) {
            userMap[username] = INVALID_SOCKET; // s·∫Ω ƒë∆∞·ª£c c·∫≠p nh·∫≠t khi accept socket th·ª±c
            std::cout << "[JOIN] " << username << " ƒë√£ tham gia ph√≤ng chat.\n";

            // G·ª≠i danh s√°ch online v·ªÅ Gateway (ho·∫∑c c√°c client kh√°c)
            std::string listMsg = "{ \"action\": \"online_list\", \"users\": [";
            bool first = true;
            for (auto& p : userMap) {
                if (!first) listMsg += ",";
                listMsg += "\"" + p.first + "\"";
                first = false;
            }
            listMsg += "] }";

            return listMsg;
        }
        return R"({"action":"error","message":"Thi·∫øu username trong join_chat"})";
    }

    // ‚úÖ Chat ri√™ng
    if (action == "private") {
        if (from.empty() || to.empty() || message.empty())
            return R"({"action":"error","message":"Thi·∫øu tham s·ªë trong g√≥i tin chat"})";

        std::string formatted =
            "{ \"action\": \"private\", \"from\": \"" + from +
            "\", \"to\": \"" + to +
            "\", \"message\": \"" + message + "\" }\n";

        sendToUser(to, formatted);
        sendToUser(from, formatted);

        db.saveMessage(from, to, message, "", "text");

        std::cout << "[CHAT] " << from << " -> " << to << ": " << message << std::endl;

        return R"({"action":"private_ok","status":"success"})";
    }


    // ‚úÖ Chat broadcast (to√†n b·ªô)
    else if (action == "public") {
        if (from.empty() || message.empty())
            return R"({"action":"error","message":"Thi·∫øu tham s·ªë trong broadcast"})";

        std::string formatted =
            "{ \"action\": \"public\", \"from\": \"" + from +
            "\", \"message\": \"" + message + "\" }\n";

        SOCKET senderSock = INVALID_SOCKET;
        {
            std::lock_guard<std::mutex> lock(mtx);
            auto it = userMap.find(from);
            if (it != userMap.end()) senderSock = it->second;
        }

        broadcast(formatted, senderSock);
        db.saveMessage(from, "ALL", message, "", "text");

        std::cout << "[BROADCAST] " << from << ": " << message << std::endl;

        return R"({"action":"broadcast_ok","status":"success"})";
    }

    // ‚úÖ L·∫•y l·ªãch s·ª≠ chat
    else if (action == "history") {
        std::vector<std::string> history = db.getHistory(from);
        std::string result = "{ \"action\": \"history\", \"messages\": [";
        for (size_t i = 0; i < history.size(); ++i) {
            if (i > 0) result += ",";
            result += "\"" + history[i] + "\"";
        }
        result += "] }";
        return result;
    }
    
    // ‚ùå Kh√¥ng h·ª£p l·ªá
    else {
        return R"({"action":"error","message":"Unknown chat action"})";
    }
}*/


